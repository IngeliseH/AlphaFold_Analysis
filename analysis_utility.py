"""
Functions to extract data from the files generated by AlphaFold

Functions:
find_rank_001_files
extract_fasta_protein_lengths
parse_cif
determine_cif_chain_lengths
extract_pae
"""
import os
import json
import re

def find_rank_001_files(folder_path, af3=False):
    """
    Search for the pdb and json files with rank_001 in the given folder.
    """
    pdb_file, json_file, PAE_png, fasta_file = None, None, None, None  # Initialize with None to avoid UnboundLocalError
    if af3 == False:
        for file in os.listdir(folder_path):
            if 'rank_001' in file or 'rank_1' in file:
                if file.endswith('.pdb'):
                    pdb_file = os.path.join(folder_path, file)
                elif file.endswith('.json'):
                    json_file = os.path.join(folder_path, file) 
            if 'pae.png' in file:
                    PAE_png = os.path.join(folder_path, file)
            if '.fasta' in file:
                    fasta_file = os.path.join(folder_path, file)
    # AF3 will have cif file instead of pdb file
    if af3 == True or not pdb_file:
        for file in os.listdir(folder_path):
            if 'model_0' in file and file.endswith('.cif'):
                pdb_file = os.path.join(folder_path, file)
            if 'full_data_0' in file and file.endswith('.json'):
                json_file = os.path.join(folder_path, file)
        PAE_png = None
        fasta_file = None
    return pdb_file, json_file, PAE_png, fasta_file

def extract_fasta_protein_lengths(fasta_file):
    """
    Extracts the lengths of the two proteins from the FASTA file.
    Assumes the fasta file contains 2 sequences separated by ':'.

    Parameters:
    fasta_file (str): Path to the FASTA file.

    Returns:
    tuple: Length of the first protein, length of the second protein.
    """
    with open(fasta_file, 'r') as file:
        lines = file.readlines()  # Read all lines in the file
        fasta_content = ''.join(lines[1:])  # Join lines starting from the second line
    sequences = fasta_content.strip().split(':')
    return len(sequences[0]), len(sequences[1])

def parse_cif(cif_file):
    """
    Parses the CIF file to identify chain, residue ID, residue name, and absolute residue ID.
    
    Parameters:
    cif_file (str): Path to the CIF file.

    Returns:
    chain_residue_map (list): List of tuples representing chain, residue ID, residue name, and absolute residue ID.
    """
    chain_residue_map = []
    unique_residues = set()
    with open(cif_file, 'r') as file:
        lines = file.readlines()
        abs_res_id = 0
        for line in lines:
            if line.startswith("HETATM") or line.startswith("ATOM"):
                # Regex to capture atom name, chain identifier, and residue number
                match = re.match(r"^(HETATM|ATOM)\s+\d+\s+\w+\s+\w+\s+\.\s+(\w+)\s+(\w)\s+\d+\s+(\d+)", line)
                if match:
                    atom_type, res_name, chain_id, res_id = match.groups()
                    res_id = int(res_id)
                    residue_tuple = (chain_id, res_id, res_name)
                    if residue_tuple not in unique_residues:
                        chain_residue_map.append((chain_id, res_id, res_name, abs_res_id))
                        unique_residues.add(residue_tuple)
                        abs_res_id += 1
    
    # Sort the chain-residue map
    chain_residue_map = sorted(chain_residue_map)

    return chain_residue_map

def determine_cif_chain_lengths(chain_residue_map):
    """
    Determines the length of each chain and its end point in the total structure 
    using the chain_residue_map.

    Parameters:
    chain_residue_map (list): List of tuples representing chain, residue ID, residue name, and absolute residue ID.

    Returns:
    list: A list of chain lengths in the order they appear.
    """
    chain_lengths = []
    current_chain_id = None
    current_chain_length = 0

    for chain_id, res_id, res_name, abs_res_id in chain_residue_map:
        if chain_id != current_chain_id:
            if current_chain_id is not None:
                chain_lengths.append(current_chain_length)
            current_chain_id = chain_id
            current_chain_length = 0
        current_chain_length += 1

    if current_chain_id is not None:
        chain_lengths.append(current_chain_length)

    return chain_lengths

def extract_pae(json_file):
    """
    Parses the PAE JSON file to extract the PAE matrix.

    Parameters:
    pae_file (str): Path to the PAE JSON file.

    Returns:
    list: PAE matrix.
    """
    with open(json_file, 'r') as file:
        data = json.load(file)
    #return data['pae'] or data['predicted_aligned_error'] if either of these is present, else error
    return data.get('pae', data.get('predicted_aligned_error', 'Error: PAE not found'))
