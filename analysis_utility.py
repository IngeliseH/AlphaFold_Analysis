"""
Functions to extract data from the files generated by AlphaFold

Functions:
find_rank_001_files
extract_fasta_protein_lengths
parse_cif
determine_cif_chain_lengths
extract_pae
"""
import json
from pathlib import Path
from Bio.PDB import PDBParser
from Bio.PDB import MMCIFParser

def find_rank_001_files(folder_path, af3=False):
    """
    Identifies the highest ranked model files in the given folder, as well as the PAE
    PNG and FASTA files if using AF2.

    Parameters:
        - folder_path (str): Path to the folder containing the model files.
        - af3 (bool): Whether the files are from AlphaFold3 (default: False).
    
    Returns:
        - tuple: Path to the PDB file, path to the JSON file, path to the PAE PNG file,
          path to the FASTA file.
    
    Note:
        - The af3 argument can be unset even if the files are from AlphaFold3 - if no
            PDB file is found, the function will automatically look for a CIF file. If
            files are from AF3, setting af3 to True will marginally increase speed.
    """
    folder = Path(folder_path)
    pdb_file, json_file, PAE_png, fasta_file = None, None, None, None
    if not af3:
        # AlphaFold2 file handling
        for file in folder.glob('*'):
            if 'rank_001' in file.stem or 'rank_1' in file.stem:
                if file.suffix == '.pdb':
                    pdb_file = file
                elif file.suffix == '.json':
                    json_file = file
            if 'pae' in file.stem and file.suffix == '.png':
                PAE_png = file
            if file.suffix == '.fasta':
                fasta_file = file
    # AF3 will have cif file instead of pdb file
    if af3 == True or not pdb_file:
        for file in folder.glob('*'):
            if 'model_0' in file.stem and file.suffix == '.cif':
                pdb_file = file
            elif 'full_data_0' in file.stem and file.suffix == '.json':
                json_file = file
    return pdb_file, json_file, PAE_png, fasta_file

def extract_fasta_protein_lengths(fasta_file):
    """
    Extracts the lengths of the two proteins from the FASTA file.
    Assumes the fasta file contains 2 sequences separated by ':'.

    Parameters:
        - fasta_file (str): Path to the FASTA file.

    Returns:
        - tuple: Length of the first protein, length of the second protein.
    """
    with open(fasta_file, 'r') as file:
        lines = file.readlines()  # Read all lines in the file
        fasta_content = ''.join(lines[1:])  # Join lines starting from the second line
    sequences = fasta_content.strip().split(':')
    return len(sequences[0]), len(sequences[1])

def parse_structure_file(file_path, is_pdb=True):
    """
    Parses the structure file (PDB or CIF) and returns the model.
    
    Parameters:
        - file_path (str): Path to the structure file.
        - is_pdb (bool): Whether the file is in PDB format (default: True).
    """
    parser = PDBParser() if is_pdb else MMCIFParser()
    structure = parser.get_structure('protein', file_path)
    model = structure[0]
    return model

def map_chains_and_residues(model):
    """
    Maps the chains and residues in the structure model to their absolute residue IDs.
    Absolute residue IDs are unique across all chains.
    
    Parameters:
        - model (Bio.PDB.Model.Model): The structure model.
        
    Returns:
        - chain_residue_map (list): List of tuples representing chain, residue ID, residue
          name, and absolute residue ID.
    """
    chain_residue_map = []
    unique_residues = set()
    abs_res_id = 0

    for chain in model.get_chains():
        chain_id = chain.id
        for residue in chain.get_residues():
            res_id = residue.id[1]
            res_name = residue.resname
            residue_tuple = (chain_id, res_id, res_name)
            if residue_tuple not in unique_residues:
                chain_residue_map.append((chain_id, res_id, res_name, abs_res_id))
                unique_residues.add(residue_tuple)
                abs_res_id += 1
    return sorted(chain_residue_map)

def determine_cif_chain_lengths(chain_residue_map):
    """
    Determines the length of each chain and its end point in the total structure 
    using the chain_residue_map.

    Parameters:
        - chain_residue_map (list): List of tuples representing chain, residue ID, residue name, and absolute residue ID.

    Returns:
        - list: A list of chain lengths in the order they appear.
    """
    chain_lengths = []
    current_chain_id = None
    current_chain_length = 0

    for chain_id, _, _, _ in chain_residue_map:
        if chain_id != current_chain_id:
            if current_chain_id is not None:
                chain_lengths.append(current_chain_length)
            current_chain_id = chain_id
            current_chain_length = 0
        current_chain_length += 1

    if current_chain_id is not None:
        chain_lengths.append(current_chain_length)

    return chain_lengths

def extract_pae(json_file):
    """
    Parses the PAE JSON file to extract the PAE matrix.

    Parameters:
        - pae_file (str): Path to the PAE JSON file.

    Returns:
        - list: PAE matrix.
    """
    with open(json_file, 'r') as file:
        data = json.load(file)
    return data.get('pae', data.get('predicted_aligned_error', 'Error: PAE not found'))
